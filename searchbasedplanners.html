<html>
<head>
	<title>
		Grid based planners | Srikanth Malla
	</title>
	<!-- <link rel="stylesheet" type="text/css" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"> -->
	<link rel="stylesheet" type="text/css" href="css/bootstrap.css">
	<link rel="stylesheet" type="text/css" href="css/styles.css">
  
  <link rel="stylesheet" href="css/tocstyles.css?v=1.1">


  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
	<script src="js/bootstrap.min.js"></script> 	
	<script src="js/main.js"></script>
  <link href="css/matlab-highlighter.css" rel="stylesheet" type="text/css">
  <script src="js/matlab-highlighter.min.js"></script>
</head>


<body onload="highlightMATLABCode();">
<nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Srikanth Malla</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li ><a href="aboutme.html">About Me <span class="sr-only">(current)</span></a></li>
        <li><a href="projects.html">Projects</a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Learn <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="planning.html">Planning</a></li>
            <li><a href="control.html">Control</a><li>
            <li><a href="perception.html">Perception</a></li>
          </ul>
        </li>
      </ul>
      <form class="navbar-form navbar-left" role="search">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Search</button>
      </form>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="publications.html">Publications</a></li>
        <li><a href="cv.html">CV</a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Video Tutorials <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="rostutorials.html">ROS</a></li>
            <!-- <li><a href="#">Another action</a></li> -->
            <!-- <li role="separator" class="divider"></li> -->
            <!-- <li><a href="#">Separated link</a></li> -->
          </ul>
        </li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

<div container>
<div class="row">
  <div class="col-sm-12">
    <div class="row">
      <div class="col-md-2">
         <div id="toc-holder" class="toc-holder" style="width: 17%;">
            <a href="#" class="toc-link" id="toc-link"><span>&#9660;</span>Go to section   </a>
            <ul id="toc" class="toc">
            <div class="toc-h1"><a href="#section1">Search based planners</a>
              <ul class="toc-sub closed">
                <a href="#section1-1">1. Dijkstra </a>
                <a href="#section1-2">2. Astar</a>
              </ul>
            </div>
          </ul>
          </div>
      </div>
      <div class="col-md-8">
        <!-- <section1> -->
        <br><br>
        <h1 id="section1-1">1. Dijkstra<h1>
        <h4>
        Dijkstra's algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.<br><br>
        The algorithm exists in many variants; Dijkstra's original variant found the shortest path between two nodes, but a more common variant fixes a single node as the "source" node and finds shortest paths from the source to all other nodes in the graph, producing a shortest-path tree.<br><br>
        Suppose you would like to find the shortest path between two intersections on a city map: a starting point and a destination. Dijkstra's algorithm initially marks the distance (from the starting point) to every other intersection on the map with infinity. This is done not to imply there is an infinite distance, but to note that those intersections have not yet been visited; some variants of this method simply leave the intersections' distances unlabeled. Now, at each iteration, select the current intersection. For the first iteration, the current intersection will be the starting point, and the distance to it (the intersection's label) will be zero. For subsequent iterations (after the first), the current intersection will be the closest unvisited intersection to the starting point (this will be easy to find).<br><br>
        From the current intersection, update the distance to every unvisited intersection that is directly connected to it. This is done by determining the sum of the distance between an unvisited intersection and the value of the current intersection, and relabeling the unvisited intersection with this value (the sum), if it is less than its current value. In effect, the intersection is relabeled if the path to it through the current intersection is shorter than the previously known paths. To facilitate shortest path identification, in pencil, mark the road with an arrow pointing to the relabeled intersection if you label/relabel it, and erase all others pointing to it. After you have updated the distances to each neighboring intersection, mark the current intersection as visited, and select the unvisited intersection with lowest distance (from the starting point) - or the lowest label-as the current intersection. Nodes marked as visited are labeled with the shortest path from the starting point to it and will not be revisited or returned to.<br><br>
        Continue this process of updating the neighboring intersections with the shortest distances, then marking the current intersection as visited and moving onto the closest unvisited intersection until you have marked the destination as visited. Once you have marked the destination as visited (as is the case with any visited intersection) you have determined the shortest path to it, from the starting point, and can trace your way back, following the arrows in reverse; in the algorithm's implementations, this is usually done (after the algorithm has reached the destination node) by following the nodes' parents from the destination node up to the starting node; that's why we keep also track of each node's parent.<br><br>
        This algorithm makes no attempt to direct "exploration" towards the destination as one might expect. Rather, the sole consideration in determining the next "current" intersection is its distance from the starting point. This algorithm therefore expands outward from the starting point, interactively considering every node that is closer in terms of shortest path distance until it reaches the destination. When understood in this way, it is clear how the algorithm necessarily finds the shortest path. However, it may also reveal one of the algorithm's weaknesses: its relative slowness in some topologies.
        </h4>
        <h3>
        Testing with sample input map
        </h3>
        <pre class="matlab-code">
map = false(10);

% Add an obstacle
map (1:5, 6) = true;

start_coords = [6, 2];
dest_coords  = [8, 9];

%%
close all;
[route, numExpanded] = DijkstraGrid (map, start_coords, dest_coords);
</pre>
        
        <!-- Matlab Simulation Code Repository:
        <div class="well">
            <h4 class="text-primary"> <a href="https://bitbucket.org/srikanthmalla/boustrophedon_decomposition">https://bitbucket.org/srikanthmalla/boustrophedon_decomposition</a> </h4> 
          </div> -->

            <img src="files/gridmap_input.JPG" height="auto" width="auto"/> ---->
           <img src="files/dijkstra_output.JPG" height="auto" width="auto"/>
        <pre class="matlab-code">
function [route,numExpanded] = DijkstraGrid (input_map, start_coords, dest_coords)
% Run Dijkstra's algorithm on a grid.
% Inputs : 
%   input_map : a logical array where the freespace cells are false or 0 and
%   the obstacles are true or 1
%   start_coords and dest_coords : Coordinates of the start and end cell
%   respectively, the first entry is the row and the second the column.
% Output :
%    route : An array containing the linear indices of the cells along the
%    shortest route from start to dest or an empty array if there is no
%    route. This is a single dimensional vector
%    numExpanded: Remember to also return the total number of nodes
%    expanded during your search


% set up color map for display
% 1 - white - clear cell
% 2 - black - obstacle
% 3 - red = visited
% 4 - blue  - on list
% 5 - green - start
% 6 - yellow - destination

cmap = [1 1 1; ...
        0 0 0; ...
        1 0 0; ...
        0 0 1; ...
        0 1 0; ...
        1 1 0;
        0.5 0.5 0.5];

colormap(cmap);

% variable to control if the map is being visualized on every
% iteration
drawMapEveryTime = true;

[nrows, ncols] = size(input_map);

% map - a table that keeps track of the state of each grid cell
map = zeros(nrows,ncols);

map(~input_map) = 1;   % Mark free cells
map(input_map)  = 2;   % Mark obstacle cells

% Generate linear indices of start and dest nodes
start_node = sub2ind(size(map), start_coords(1), start_coords(2));
dest_node  = sub2ind(size(map), dest_coords(1),  dest_coords(2));

map(start_node) = 5;
map(dest_node)  = 6;

% Initialize distance array
distanceFromStart = Inf(nrows,ncols);

% For each grid cell this array holds the index of its parent
parent = zeros(nrows,ncols);

distanceFromStart(start_node) = 0;

% keep track of number of nodes expanded 
numExpanded = 0;

% Main Loop
while true
    
    % Draw current map
    map(start_node) = 5;
    map(dest_node) = 6;
    
    % make drawMapEveryTime = true if you want to see how the 
    % nodes are expanded on the grid. 
    if (drawMapEveryTime)
        image(1.5, 1.5, map);
        grid on;
        axis image;
        drawnow;
    end
    
    % Find the node with the minimum distance
    [min_dist, current] = min(distanceFromStart(:))
    
    if ((current == dest_node) || isinf(min_dist))
        break;
    end;
    
    % Update map
    map(current) = 3;         % mark current node as visited
    distanceFromStart(current) = Inf; % remove this node from further consideration
    
    % Compute row, column coordinates of current node
    [i, j] = ind2sub(size(distanceFromStart), current);
    
   % ********************************************************************* 
    % YOUR CODE BETWEEN THESE LINES OF STARS

    ii=0;
    jj=0;
    if (i>1 && i<=nrows)
        ii = i-1;
        jj = j;
        if (map(ii,jj)~=2 && map(ii,jj)~=3 && map(ii,jj)~=5)
            map(ii,jj) = 4;
            parent(ii,jj) = current;
            distanceFromStart(ii,jj) = min_dist+1;
        end
    end
    if (i>=1 && i< nrows)
        ii = i+1;
        jj = j;
        if (map(ii,jj)~=2 && map(ii,jj)~=3 && map(ii,jj)~=5)
            map(ii,jj) = 4;
            parent(ii,jj) = current;
            distanceFromStart(ii,jj) = min_dist+1;
        end
    end
    if (j>1 && j<=ncols)
        jj = j-1;
        ii = i;
        if (map(ii,jj)~=2 && map(ii,jj)~=3 && map(ii,jj)~=5)
            map(ii,jj) = 4;
            parent(ii,jj) = current;
            distanceFromStart(ii,jj) = min_dist+1;
        end
    end
    if (j>=1 && j< ncols)
        jj =j+1;
        ii = i;
        if (map(ii,jj)~=2 && map(ii,jj)~=3 && map(ii,jj)~=5)
            map(ii,jj) = 4;
            parent(ii,jj) = current;
            distanceFromStart(ii,jj) = min_dist+1;
        end
    end
    
    numExpanded = numExpanded + 1;

    % Visit each neighbor of the current node and update the map, distances
    % and parent tables appropriately.

    %*********************************************************************

end

%% Construct route from start to dest by following the parent links
if (isinf(distanceFromStart(dest_node)))
    route = [];
else
    route = [dest_node];
    
    while (parent(route(1)) ~= 0)
        route = [parent(route(1)), route];
    end
    
        % Snippet of code used to visualize the map and the path
    for k = 2:length(route) - 1        
        map(route(k)) = 7;
        pause(0.1);
        image(1.5, 1.5, map);
        grid on;
        axis image;
    end
end

end
      </pre>
      
     <h1 id="section1-2">2. A star<h1>
        <h4>
        In computer science, A* is a computer algorithm that is widely used in pathfinding and graph traversal, the process of plotting an efficiently traversable path between multiple points, called nodes. Noted for its performance and accuracy, it enjoys widespread use. However, in practical travel-routing systems, it is generally outperformed by algorithms which can pre-process the graph to attain better performance, although other work has found A* to be superior to other approaches.<br><br>
        Peter Hart, Nils Nilsson and Bertram Raphael of Stanford Research Institute (now SRI International) first described the algorithm in 1968. It is an extension of Edsger Dijkstra's 1959 algorithm. A* achieves better performance by using heuristics to guide its search.<br><br>
        A* is an informed search algorithm, or a best-first search, meaning that it solves problems by searching among all possible paths to the solution (goal) for the one that incurs the smallest cost (least distance travelled, shortest time, etc.), and among these paths it first considers the ones that appear to lead most quickly to the solution. It is formulated in terms of weighted graphs: starting from a specific node of a graph, it constructs a tree of paths starting from that node, expanding paths one step at a time, until one of its paths ends at the predetermined goal node.<br><br>
        At each iteration of its main loop, A* needs to determine which of its partial paths to expand into one or more longer paths. It does so based on an estimate of the cost (total weight) still to go to the goal node. Specifically, A* selects the path that minimizes f(n)=g(n)+h(n)<br><br>
        where n is the last node on the path, g(n) is the cost of the path from the start node to n, and h(n) is a heuristic that estimates the cost of the cheapest path from n to the goal. The heuristic is problem-specific. For the algorithm to find the actual shortest path, the heuristic function must be admissible, meaning that it never overestimates the actual cost to get to the nearest goal node.<br><br>
        Typical implementations of A* use a priority queue to perform the repeated selection of minimum (estimated) cost nodes to expand. This priority queue is known as the open set or fringe. At each step of the algorithm, the node with the lowest f(x) value is removed from the queue, the f and g values of its neighbors are updated accordingly, and these neighbors are added to the queue. The algorithm continues until a goal node has a lower f value than any node in the queue (or until the queue is empty). The f value of the goal is then the length of the shortest path, since h at the goal is zero in an admissible heuristic.<br><br>
        The algorithm described so far gives us only the length of the shortest path. To find the actual sequence of steps, the algorithm can be easily revised so that each node on the path keeps track of its predecessor. After this algorithm is run, the ending node will point to its predecessor, and so on, until some node's predecessor is the start node.<br><br>
        As an example, when searching for the shortest route on a map, h(x) might represent the straight-line distance to the goal, since that is physically the smallest possible distance between any two points.<br><br>
        If the heuristic h satisfies the additional condition h(x) <= d(x, y) + h(y) for every edge (x, y) of the graph (where d denotes the length of that edge), then h is called monotone, or consistent. In such a case, A* can be implemented more efficiently-roughly speaking, no node needs to be processed more than once and A* is equivalent to running Dijkstra's algorithm with the reduced cost d'(x,y) = d(x, y)+h(y)-h(x).<br><br>
        Additionally, if the heuristic is monotonic (or consistent, see below), a closed set of nodes already traversed may be used to make the search more efficient.
        </h4>
        <h3>
        Testing with sample input map
        </h3>
        <pre class="matlab-code">
map = false(10);

% Add an obstacle
map (1:5, 6) = true;

start_coords = [6, 2];
dest_coords  = [8, 9];

%%
close all;
[route, numExpanded] = AStarGrid (map, start_coords, dest_coords);
</pre>
        
        <!-- Matlab Simulation Code Repository:
        <div class="well">
            <h4 class="text-primary"> <a href="https://bitbucket.org/srikanthmalla/boustrophedon_decomposition">https://bitbucket.org/srikanthmalla/boustrophedon_decomposition</a> </h4> 
          </div> -->

            <img src="files/gridmap_input.JPG" height="auto" width="auto"/> ---->
           <img src="files/astar_output.JPG" height="auto" width="auto"/>
        
        <pre class="matlab-code">
function [route,numExpanded] = AStarGrid (input_map, start_coords, dest_coords)
% Run A* algorithm on a grid.
% Inputs : 
%   input_map : a logical array where the freespace cells are false or 0 and
%   the obstacles are true or 1
%   start_coords and dest_coords : Coordinates of the start and end cell
%   respectively, the first entry is the row and the second the column.
% Output :
%    route : An array containing the linear indices of the cells along the
%    shortest route from start to dest or an empty array if there is no
%    route. This is a single dimensional vector
%    numExpanded: Remember to also return the total number of nodes
%    expanded during your search

% set up color map for display
% 1 - white - clear cell
% 2 - black - obstacle
% 3 - red = visited
% 4 - blue  - on list
% 5 - green - start
% 6 - yellow - destination

cmap = [1 1 1; ...
    0 0 0; ...
    1 0 0; ...
    0 0 1; ...
    0 1 0; ...
    1 1 0;
    0.5 0.5 0.5];

colormap(cmap);

% variable to control if the map is being visualized on every
% iteration
drawMapEveryTime = true;

[nrows, ncols] = size(input_map);

% map - a table that keeps track of the state of each grid cell
map = zeros(nrows,ncols);

map(~input_map) = 1;   % Mark free cells
map(input_map)  = 2;   % Mark obstacle cells

% Generate linear indices of start and dest nodes
start_node = sub2ind(size(map), start_coords(1), start_coords(2));
dest_node  = sub2ind(size(map), dest_coords(1),  dest_coords(2));

map(start_node) = 5;
map(dest_node)  = 6;

% meshgrid will `replicate grid vectors' nrows and ncols to produce
% a full grid
% type `help meshgrid' in the Matlab command prompt for more information
parent = zeros(nrows,ncols);

% 
[X, Y] = meshgrid (1:ncols, 1:nrows);

xd = dest_coords(2);
yd = dest_coords(1);

% Evaluate Heuristic function, H, for each grid cell
% Manhattan distance
H = abs(X - xd) + abs(Y - yd);

% Initialize cost arrays
f = Inf(nrows,ncols);
g = Inf(nrows,ncols);

g(start_node) = 0;
f(start_node) = H(start_node);

% keep track of the number of nodes that are expanded
numExpanded = 0;

% Main Loop

while true
    
    % Draw current map
    map(start_node) = 5;
    map(dest_node) = 6;
    
    % make drawMapEveryTime = true if you want to see how the 
    % nodes are expanded on the grid. 
    if (drawMapEveryTime)
        image(1.5, 1.5, map);
        grid on;
        axis image;
        drawnow;
    end
    
    % Find the node with the minimum f value
    [min_f, current] = min(f(:));
    
    if ((current == dest_node) || isinf(min_f))
        break;
    end;
    
    % Update input_map
    map(current) = 3;
    %f(current) = Inf; % remove this node from further consideration
    
    % Compute row, column coordinates of current node
    [i, j] = ind2sub(size(f), current);
    
    % *********************************************************************
    % ALL YOUR CODE BETWEEN THESE LINES OF STARS
    % Visit all of the neighbors around the current node and update the
    % entries in the map, f, g and parent arrays
    %
%     pause(0.5)
    ii=0;
    jj=0;
    if (i>1 && i<=nrows) %% UP
        ii = i-1;
        jj = j;
        if (map(ii,jj)~=2 && map(ii,jj)~=3 && map(ii,jj)~=5)
            if g(ii,jj) > (g(i,j) + (H(ii,jj)-H(i,j)))
                g(ii,jj) = g(i,j) + (H(ii,jj)-H(i,j));
                f(ii,jj) = g(ii,jj) + H(ii,jj);
                map(ii,jj) = 4;
                parent(ii,jj) = current;
            end
        end
    end
    if (i>=1 && i< nrows) % DOWN
        ii = i+1;
        jj = j;
        if (map(ii,jj)~=2 && map(ii,jj)~=3 && map(ii,jj)~=5)
            if g(ii,jj) > (g(i,j) + (H(ii,jj)-H(i,j)))
                g(ii,jj) = g(i,j) + (H(ii,jj)-H(i,j));
                f(ii,jj) = g(ii,jj) + H(ii,jj);
                map(ii,jj) = 4;
                parent(ii,jj) = current;
            end
        end
    end
    if (j>1 && j<=ncols) % LEFT
        jj = j-1;
        ii = i;
        if (map(ii,jj)~=2 && map(ii,jj)~=3 && map(ii,jj)~=5)
            if g(ii,jj) > (g(i,j) + (H(ii,jj)-H(i,j)))
                g(ii,jj) = g(i,j) + (H(ii,jj)-H(i,j));
                f(ii,jj) = g(ii,jj) + H(ii,jj);
                map(ii,jj) = 4;
                parent(ii,jj) = current;
            end
        end
    end
    if (j>=1 && j< ncols) %RIGHT
        jj =j+1;
        ii = i;
        if (map(ii,jj)~=2 && map(ii,jj)~=3 && map(ii,jj)~=5)
            if g(ii,jj) > (g(i,j) + (H(ii,jj)-H(i,j)))
                g(ii,jj) = g(i,j) + (H(ii,jj)-H(i,j));
                f(ii,jj) = g(ii,jj) + H(ii,jj);
                map(ii,jj) = 4;
                parent(ii,jj) = current;
            end
        end
    end
    
    numExpanded = numExpanded + 1;
    %*********************************************************************
end

%% Construct route from start to dest by following the parent links
if (isinf(f(dest_node)))
    route = [];
else
    route = [dest_node];
    
    while (parent(route(1)) ~= 0)
        route = [parent(route(1)), route];
    end

    % Snippet of code used to visualize the map and the path
    for k = 2:length(route) - 1        
        map(route(k)) = 7;
        pause(0.1);
        image(1.5, 1.5, map);
        grid on;
        axis image;
    end
end
end        
      </pre>
      </div>  
    </div><!--/row-->    
  </div><!--/col-12-->
</div><!--/row-->
</div>

<script src="js/jquery.fixedTOC.js?v=3.0"></script>
<script>
// call the plugin on the "#toc" element
$('#toc').fixedTOC({
  menuOpens: 'click', // or 'mouseenter'
  scrollSpeed: 1000,
  menuSpeed: 300,
  useSubMenus: true,
  resetSubMenus: true,
  topLinkWorks: true
});
</script>

</body> 
</html>